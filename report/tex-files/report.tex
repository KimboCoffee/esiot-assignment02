\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{cleveref}

\title{Embedded Systems and Internet-of-Things \\ - \\ Second Assignment}

\author{Kimi Osti}
\date{\today}


\begin{document}
	
	\maketitle
	
	\begin{abstract}
		The main goal of this project is to realize a Smart Liquid Waste Disposal Container. It will be based on an Arduino UNO Board linked to a computer via serial communication. In this system, some hardware devices will be dedicated to user interaction, opening or closing the container, or exchanging some basic information via a screen. Then, a subsystem will be dedicated to waste monitoring, revealing when the container is too full or its content is too hot, blocking user interaction. To solve these problems, an operator will have to intervene via the computer to empty the container or to signal that the temperature situation is now under control.
	\end{abstract}
	
	\tableofcontents
	
	\chapter{Domain Analysis}
	The domain analysis, working on an embedded system, can be conducted on two levels: hardware and software.
	
	\section{Hardware}
	Besides the main container, which is by no means an active hardware device, some main components can be highlighted from a functional standpoint:
	
	\subsection{User Detector}
	The user detector has the main function of revealing when a user is nearby. This is needed to wake the system from low power consumption mode when a potential user approaches the system.\newline
	It is realized with an infrared passive sensor (PIR), whose functioning is based on infrared variations in the environment. These devices, powered with a tension, return a digital output on a pin when they detect abrupt infrared variations. In \href{https://learn.adafruit.com/pir-passive-infrared-proximity-motion-sensor/}{the variant used} for this project, there are two knobs on the back to regulate sensitivity and delay time, two key factors to detect changes. Due to the fact that these devices work on variations of infrared instead of absolute values, a calibration time on system startup might have to be taken into account.
	
	\subsection{Waste Level Detector}
	The waste level detector has the vital function of detecting the amount of waste introduced in the container. This has to be monitored so that a maximum level is never exceeded.\newline
	It can be realized thanks to a proximity sensor, which detects how close the level of waste is to the top of the container. When this distance goes below a certain defined threshold, it means the container is too full. For our project, an \href{https://docs.google.com/document/d/1Y-yZnNhMYy7rwhAgyL_pfa39RsB-x2qR4vP8saG73rE/edit?tab=t.0}{ultrasound proximity sensor} is used rather than a light proximity sensor. This because it allows greater precision on shorter distances (because of how much sound is slower than light) and because it is less sensitive of orientation of the measured object. This device is powered by a trigger impulse, which produces a sound that is captured back and produces an echo impulse. Measuring the time elapsed between these two signals, and knowing - even approximately - the speed of sound through air a measure of distance can be obtained.
	
	\subsection{Door}
	The container's door is realized here thanks to an electrical motor, which is oriented to a certain angle to open or close the container.\newline
	Rather than using DC motors, in which the angle can't be specified, or stepper motors, that offer a fine grained rotating precision but are very expensive, we have chosen to use \href{https://www.kjell.com/globalassets/mediaassets/701916_87897_datasheet_en.pdf?ref=4287817A7A}{a servo motor}. It has a range of about 180Â°, which is enough if applied to a door's control, and it offers the possibility to control the angle of its rotation in an easy way. For it to work properly, a servo motor requires that electrical pulses of a certain duration (corresponding to the angle) are sent to it at a fixed frequency, so that it is oriented to meet the desired angle. Particular attention has to be paid to how much the door resists to rotation because electrical consumption depends on this, so having a door that weights too much can damage the UNO Board because of current consumption.
	
	\subsection{Open and Close buttons}
	These are two simple tactile buttons linked to the UNO Board.\newline
	Their functioning is based on the fact that they receive power from the board, and transfer it back to it via some pin when they are pressed. In order to have 0 rather than VCC as the default value, a pull down resistor - 10KOhm in our case - is needed to connect the button to the ground.
	
	\subsection{Red and Green LEDs}
	These are two LEDs used to signal to the user the state of the system: green is turned on when the container is in a ready-to-use state, while red signals some problem that blocks the system functions.\newline
	In order for the LEDs to work, tension has to be applied on their two ends: the anode is connected to a pin powering it based on the desired output value, and the cathode is connected to the ground. Since the LEDs used for this project require a tension of 2V to work properly, and Arduino UNO's VCC is 5V, a 220Ohm resistor is needed in order to lower the tension at the ends of each LED.
	
	\subsection{User Screen}
	This device is used to show the user some simple information, such as the fact that the system is ready to accept waste and how to open it.\newline
	In our system, a \href{https://robot-italy.com/products/16x2-lcd-display-green?_pos=3&_psq=display+lcd&_ss=e&_v=1.0}{green background Liquid Crystal Display} is used for this function. More specifically, it's used with a \href{https://en.wikipedia.org/wiki/I%C2%B2C}{I2C} adapter, to exploit its features occupying less pins on the board.
	
	\subsection{Temperature Sensor}
	This device is needed to monitor the waste temperature.\newline
	It can be realized using a simple analog temperature sensor. These devices are based on the fact that temperature increases or decreases the electricity flow through them, and an analog signal is returned to the board according to the temperature value. Starting from this analog value, knowing voltage and temperature ranges of the devices (which have to be read on technical data sheets) the measure can be easily obtained via some mathematical formula. In this case, a \href{https://www.analog.com/en/products/tmp36.html?doc=TMP35_36_37.pdf#part-details}{TMP36 temperature sensor} was used.
	
	\subsection{Operator Dashboard}
	The operator dashboard is meant to be accessed only by operators, and it has to be connected to the Arduino UNO Board.\newline
	In our system, it will be hosted on a separate general purpose computer, in which a program will run to handle the dashboard's features. Connection will be achieved via serial communication, exploiting the USB connection offered by the Arduino UNO Board.
	
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.50]{img/HW-domain.png}
		\caption{Schematic disposition of hardware devices, from the \href{https://docs.google.com/document/d/1iFXGmo7RVZMpJ5bxUN5ms_qFqg2B-wecRc0sfas9rQ4/edit?usp=sharing}{professor's assignment}}
		\label{img:hw-domain}
	\end{figure}
	
	\section{Software}
	Software domain analysis can be divided in two main modules, one running on the Arduino UNO Board (the Smart Waste Disposal Control Unit) and the other running on the computer connected to it (the Operator Dashboard Application).
	
	\subsection{Smart Waste Disposal Control Unit}
	This is the core unit of the device, being the one that directly controls and regulates the behavior of the entire system.\newline
	The main constraint in terms of technologies is that it has to be programmed in C++ with the Wiring framework, since it will run on an Arduino UNO Board. Trying to dissect the system's behavior, it can easily be decomposed in three main Finite States Machines that run in parallel.
	
	\subsubsection{Temperature Monitor FSM}
	The temperature monitor, with its behavior, can be modeled as a Finite State Machine. It behaves regardless of the state in which the other parts of the systems are, signaling whenever an exception happens.
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.60]{img/temp-monitor-FSM.png}
		\caption{FSM for the temperature monitor}
		\label{img:temp-monitor-FSM}
	\end{figure}
	In this scheme, \emph{Working} should be interpreted as any state of the main FSM, to which a signal is sent when entering the \emph{NonWorking} state. In this way, the main FSM can regulate its own behavior according to the state signaled by this sensor. 
	
	\subsubsection{Level of Waste Monitor FSM}
	This sensor, similarly to the temperature sensor, can be modeled with an independent FSM that can signal exceptions to the main FSM. 
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.60]{img/waste-level-monitor-FSM.png}
		\caption{FSM for the waste level monitor}
		\label{img:waste-level-FSM}
	\end{figure}
	Like in the previous scheme, \emph{Working} refers to any state of the main FSM, and \emph{NonWorking} refers to a generic state in which an exception is received and the normal functions of the system are suspended. Also for this feature, signals between distinct FSMs regulate the system overall behavior.
	
	\subsubsection{Main FSM}
	The main life cycle of the system can be described as a separate FSM.
	\begin{figure}[H]
		\centering{}
		\includegraphics[scale=0.60]{img/main-FSM.png}
		\caption{FSM for the main system life cycle}
		\label{img:main-FSM}
	\end{figure}
	In this FSM, \emph{SensorException} is any kind of signal that is sent from a sensor to the system to stop its default life cycle. On the other hand, \emph{DashboardProblemSolved} is the corresponding dashboard operation that restores the system's functions.
	
	\subsection{Operator Dashboard Application}
	The Operator Dashboard Application is a software module running on a general purpose PC. It's supposed to show a Graphical User Interface to the Operator, a qualified user that can restore the normal functioning of the container, emptying it or resetting it after a critical temperature situation.\newline
	This project component must feature these two functions, plus optionally the ability to inspect some data history, but is on any other aspect - such as programming language or software architecture - freely developed by the programmer, who will chose its preferred technologies.
	
	\chapter{Development}
	The development solutions can be naturally split in the two separate domains that have to be realized: the embedded system itself and the Operator Dashboard Application, called here the Computer System since it runs on a general purpose PC.
	
	\section{Hardware Devices}
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{img/circuit-detail.png}
		\caption{\href{https://www.tinkercad.com/things/1OaxE8QuWbw-esiot-assignment02?sharecode=9QQajaw8It3u4rzvy1XqA17RKAIlDJlUtWD6_dBJsmI}{Full circuit in detail}}
		\label{img:full-circuit}
	\end{figure}
	
	\section{Embedded System}
	The software for the Embedded System is developed with the \href{https://wiring.org.co/}{Wiring framework}, which is based on C++ and allows to exploit all the features of the language adding some high level interfaces for hardware interaction purposes. This framework, based on a super loop architecture, very well fits Embedded Systems programming, since they require to run non-stop. Furthermore, being based on C++, it allows the programmer to exploit Object Oriented Programming, that very effectively represents this kind of systems, in which different devices work together and exchange messages.
	
	\subsection{Software Architecture}
	From an architectural standpoint, the software for the embedded system is developed as a synchronous Finite State Machine. This means that it runs according to a fixed period, which serves as the time unit. Each of the three Finite State Machines in which the system was divided in the Analysis section can be represented more properly as a Task in the global Finite State Machine that represents the entire Embedded System. This means that the system runs at a given period, which has to be decided according to the single Task needs, and that a scheduler is needed to coordinate Task execution.
	\newline In particular, this system runs on a round-robin cooperative scheduler. This means that - each period - control is given in turn to all Tasks, which have to atomically perform a finite step, since the scheduler doesn't stop its execution as it would do in preemptive scheduling. This is easier to implement, and can be achieved in this system because every task has relatively simple operations to perform at each step, and therefore is considered to be non-blocking. The main consequence of implementing a round-robin scheduler is that it defines implicit priorities between Tasks, since control is given in a certain order each period. This has to be taken into account when dealing with inter-task communication, since the sources of messages have to synchronize with their receivers. Another important concern is the choice of the period: each period must be long enough to allow all Tasks to execute, but it also has to be an exact divisor of all Tasks' own periods. This because otherwise it would mean losing responsiveness to Task operations. In particular, an ideal period for responsiveness would be the Greatest Common Divisor between all Task periods, but on the other hand it might result in a time too short to allow each Task to execute its step (note that in the worst case scenario, which certainly happens at some time in execution, all Tasks have to perform their step in a single period). In this system though, since there are only a few Tasks that can have relatively long periods (tens to hundreds of milliseconds), it is not really a big issue.
	\newline For what concerns Tasks, together with the three main Tasks depicted in the Analysis, a Communication Task has to be implemented. Each period, it will read the last measure of the temperature and the filling level of the container, along with the sensors' states. This data will be used for serial communication towards the computer. In addition to that, this Task has to collect data from the serial line and restore the system's state in case the exceptions are solved through the Dashboard.
	\newline Below those Tasks, an object tracking whether the system is working correctly is needed. This object is exploited to allow inter-Task communication and to represent shared state between separate Tasks.
	\newline Orienting the analysis more towards the devices that compose the system, each device can be represented as an object. This allows maximum flexibility for their behavior and their communication, and could also offer scalability to implement more complex solutions (for example, the temperature monitoring task could register multiple sensors to improve the quality of its measures).
	
	\subsection{Implementing Choices}
	To implement the LCD Screen behavior, the \href{https://docs.arduino.cc/libraries/liquidcrystal-i2c/}{LiquidCrystal I2C library} was used. This library relies on I2C protocol to allow communication between the Arduino board and a LCD screen, providing a wrapper class to handle all its features without dealing with low level aspects of the protocol.
	\newline The PIR user detector is connected to pin 2. This because pin 2 allows interrupts by default, and it comes in handy when the system goes in deep sleep state. Indeed, the only way to wake up the Arduino UNO board from deep sleep is through interrupts. This means that interrupts are not used in the system default behavior, but an empty routine can be attached to the user detector pin before going to deep sleep, in order to provide a way to wake up the system.
	\newline The door is implemented through a servo motor relying on the \href{https://github.com/nabontra/ServoTimer2}{Servo Timer 2} library. It exposes a wrapper class to handle servo motors, and under the hood exploits timer 2, leaving timer 1 free for eventual scheduling purposes. This has to be considered because timer 1 is 16bit, while the other two timers are 8bit and allow - even with the largest possible prescaler - timeout events every few milliseconds, becoming unsuitable for time measuring purposes if periods exceed some limited threshold.
	\newline For what concerns time measuring, a simple wrapper class named TimerImpl was implemented. It exploits the \href{https://github.com/sstaub/Timer}{Timer library}, which isn't interrupt based. This remains consistent to the rest of the project, in which no feature is interrupt-driven, except from the necessary sleep-related PIR interrupt.
	\newline The level measurement device is realized thanks to a sonar, and it is programmed to auto-calibrate. This is done to enhance portability between different hardware systems, but requires the system to be empty on Arduino startup. Another note is that it considers the temperature to be fixed at 20Â°C. This is done because it offers a quite good approximation - it's considered to be the standard temperature - and because measurements couldn't rely on the temperature sensor since it measures the liquid temperature rather than the air temperature.
	\newline To handle inter-Task communication, some Tasks will hold reference to other objects. In particular, each Task will hold a reference to the System State Tracker, while the Serial Communication Task will also hold a reference to both the Temperature and Filling Level Tasks, so that it can read their values and forward them to the computer.
	
	\section{Computer System}
	The computer system is here implemented in Python, since it allows to simply create user interfaces and serial communication.\newline
	Particularly, \href{https://docs.python.org/3/library/tkinter.html}{the tkinter interface package} is used for producing the user interface. This package serves as an interface for the Tcl/Tk GUI toolkit, and simplifies the development process behind GUIs.\newline
	Serial communication, on the other hand, is achieved thanks to \href{https://pyserial.readthedocs.io/en/latest/}{the serial module of the pyserial library}. This module tackles the low-level parts of the serial communication implementation, and allows the programmer to deal with higher level matters.\newline
	From an implementing standpoint, the System consists on three main modules: a Message Handler, the App and the View. The App controls the application's flow, updating each period the View to correctly represent the data read by the Message Handler.
	\paragraph{Communication protocol} To ensure effective communication, a simple protocol is established between the two systems.
	\newline From Arduino towards the computer, each message contains 5 lines. They represent respectively the current scheduler period, the measured temperature, the eventual occurring of a temperature exception, the current waste level and the eventual occurring of a level exception.
	\newline From the computer towards Arduino, communication is much simpler. Since it has just two possible values to signal, a byte is enough. In particular, 1 is coded to represent the temperature restoring, and 2 is coded to represent the emptying command.
	\newline \b{NOTE:} to synchronize communication, the PC clears its input buffer before starting to read values, so that it won't read older values still living in memory, but reads only the real-time values written by the board.
	
	\chapter{System Demonstration}
	\href{https://drive.google.com/file/d/1WgMCrVB_kaROzejK9e0wBk0y-nm3afkx/view?usp=sharing}{This is a simple demonstration of the system.}
	
\end{document}
